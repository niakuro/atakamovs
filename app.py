# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17xMLrQtghyYz1mFwe2gEQHcTT_rCykc7
"""

import random
from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit, join_room, leave_room

app = Flask(__name__)
app.config['SECRET_KEY'] = 'kanzoku-kun-v3.1-ultimate'
socketio = SocketIO(app)

# ルーム管理用の辞書
rooms = {}  # {room_id: GameInstance}
player_rooms = {}  # {sid: room_id} セッションIDからルームIDへのマッピング
room_players = {}  # {room_id: {'p1': sid, 'p2': sid}} ルームごとのプレイヤー割り当て

# --- 55種類のカードデータベース ---
CARD_DB = [
    {"id": "Newbie", "name": "新入社員", "cost": 1, "power": 1, "type": "MACHINE", "category": "人材", "upkeep": 0, "desc": "【登場時】1枚引く。"},
    {"id": "Staff", "name": "担当社員", "cost": 3, "power": 4, "type": "MACHINE", "category": "人材", "upkeep": 1, "desc": "新入社員から進化(1)。"},
    {"id": "Chief", "name": "主任技術者", "cost": 5, "power": 8, "type": "MACHINE", "category": "人材", "upkeep": 0, "desc": "担当社員から進化(1)。維持費0。"},
    {"id": "Senior", "name": "教育係の先輩", "cost": 2, "power": 3, "type": "MACHINE", "category": "人材", "upkeep": 1, "desc": "新入社員のパワー+3。"},
    {"id": "Ace", "name": "現場のエース", "cost": 4, "power": 12, "type": "MACHINE", "category": "人材", "upkeep": 2, "desc": "高出力な現場員。"},
    {"id": "Leader", "name": "現場代理人", "cost": 6, "power": 15, "type": "MACHINE", "category": "人材", "upkeep": 1, "desc": "パワーが高いが低維持費。"},
    {"id": "Expert", "name": "ベテラン職人", "cost": 5, "power": 10, "type": "MACHINE", "category": "人材", "upkeep": 2, "desc": "安定した計測値。"},
    {"id": "Clerk", "name": "事務員", "cost": 2, "power": 1, "type": "MACHINE", "category": "人材", "upkeep": 0, "desc": "毎ターンAP+1回復。"},
    {"id": "Intern", "name": "実習生", "cost": 0, "power": 0, "type": "MACHINE", "category": "人材", "upkeep": 0, "desc": "コスト0の囮。"},
    {"id": "SafetyOfficer", "name": "安全管理員", "cost": 3, "power": 2, "type": "MACHINE", "category": "人材", "upkeep": 1, "desc": "現場の守り神。"},
    {"id": "LevelBasic", "name": "普通のレベル", "cost": 1, "power": 2, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "基本機材。"},
    {"id": "LevelAuto", "name": "オートレベル", "cost": 3, "power": 6, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "普通レベルから進化(1)。"},
    {"id": "StaffBasic", "name": "アルミスタッフ", "cost": 1, "power": 2, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "基本スタッフ。"},
    {"id": "StaffRef", "name": "反射スタッフ", "cost": 3, "power": 7, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "アルミから進化(1)。"},
    {"id": "TS", "name": "光波TS", "cost": 4, "power": 10, "type": "MACHINE", "category": "機材", "upkeep": 2, "desc": "主力機材。"},
    {"id": "GNSS", "name": "GNSS衛星", "cost": 6, "power": 18, "type": "MACHINE", "category": "機材", "upkeep": 3, "desc": "晴天時パワー+5。"},
    {"id": "Drone", "name": "UAVドローン", "cost": 5, "power": 14, "type": "MACHINE", "category": "機材", "upkeep": 2, "desc": "濃霧の影響を受けない。"},
    {"id": "Scanner", "name": "3Dスキャナ", "cost": 8, "power": 25, "type": "MACHINE", "category": "機材", "upkeep": 3, "desc": "最高クラスの出力。"},
    {"id": "UsedTS", "name": "中古のTS", "cost": 2, "power": 12, "type": "MACHINE", "category": "機材", "upkeep": 2, "desc": "安価だが維持費がかさむ。"},
    {"id": "Laser", "name": "レーザー墨出し", "cost": 2, "power": 5, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "室内で真価を発揮。"},
    {"id": "Compass", "name": "コンパス", "cost": 1, "power": 1, "type": "MACHINE", "category": "機材", "upkeep": 0, "desc": "方位を計測。"},
    {"id": "Tripod", "name": "三脚", "cost": 1, "power": 1, "type": "MACHINE", "category": "機材", "upkeep": 0, "desc": "機材の土台。"},
    {"id": "Caliper", "name": "ノギス", "cost": 1, "power": 2, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "精密計測。"},
    {"id": "Scale", "name": "スケール", "cost": 1, "power": 1, "type": "MACHINE", "category": "機材", "upkeep": 0, "desc": "基本。"},
    {"id": "Chalk", "name": "チョーク", "cost": 1, "power": 1, "type": "MACHINE", "category": "機材", "upkeep": 0, "desc": "マーキング用。"},
    {"id": "Excavator", "name": "バックホー", "cost": 7, "power": 20, "type": "MACHINE", "category": "機材", "upkeep": 4, "desc": "圧倒的パワー。"},
    {"id": "Rental", "name": "レンタル重機", "cost": 3, "power": 15, "type": "MACHINE", "category": "機材", "upkeep": 5, "desc": "維持費が非常に高い。"},
    {"id": "SmallTruck", "name": "軽トラ", "cost": 2, "power": 1, "type": "MACHINE", "category": "機材", "upkeep": 0, "desc": "設置をスムーズにする。"},
    {"id": "Concrete", "name": "生コン車", "cost": 5, "power": 10, "type": "MACHINE", "category": "機材", "upkeep": 3, "desc": "雨天時パワー-5。"},
    {"id": "Pump", "name": "排水ポンプ", "cost": 3, "power": 0, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "豪雨のマイナスを無効化。"},
    {"id": "GenSet", "name": "発電機", "cost": 3, "power": 3, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "他機材のパワー+2。"},
    {"id": "Radio", "name": "無線機", "cost": 2, "power": 2, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "ドローンを強化。"},
    {"id": "Lights", "name": "投光器", "cost": 3, "power": 4, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "後半でパワーアップ。"},
    {"id": "Helmet", "name": "ヘルメット", "cost": 1, "power": 0, "type": "MACHINE", "category": "機材", "upkeep": 0, "desc": "人材コストを軽減。"},
    {"id": "Barrier", "name": "工事看板", "cost": 2, "power": 0, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "相手の行動を抑制。"},
    {"id": "Elite", "name": "少数精鋭", "cost": 2, "power": 0, "type": "SPELL", "desc": "最大AP-1。2枚引く。"},
    {"id": "Decision", "name": "苦渋の決断", "cost": 0, "power": 0, "type": "SPELL", "desc": "手札から強カードを捨て最大AP+2。"},
    {"id": "Fund", "name": "資金調達", "cost": 4, "power": 0, "type": "SPELL", "desc": "永久に最大AP+1。"},
    {"id": "Transceiver", "name": "トランシーバー", "cost": 1, "power": 0, "type": "SPELL", "desc": "デッキから1枚引く。"},
    {"id": "Safety", "name": "安全巡回", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手の最大AP-1。"},
    {"id": "Lost", "name": "紛失事故", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手のパワー10以上を1台破壊。"},
    {"id": "Note", "name": "電子野帳", "cost": 1, "power": 0, "type": "SPELL", "desc": "カードを2枚引く。"},
    {"id": "Repair", "name": "緊急修理", "cost": 2, "power": 0, "type": "SPELL", "desc": "APを5回復する。"},
    {"id": "Check", "name": "Wチェック", "cost": 2, "power": 0, "type": "SPELL", "desc": "カードを3枚引く。"},
    {"id": "Bush", "name": "藪払い", "cost": 2, "power": 0, "type": "SPELL", "desc": "相手の低コスト機を破壊。"},
    {"id": "Rush", "name": "突貫工事", "cost": 0, "power": 0, "type": "SPELL", "desc": "このターンAP+4。終了時、場の1台自壊。"},
    {"id": "Consult", "name": "気象予報", "cost": 1, "power": 0, "type": "SPELL", "desc": "次ターンの天候を晴天にする。"},
    {"id": "Training", "name": "資格手当", "cost": 2, "power": 0, "type": "SPELL", "desc": "社員1人のパワー+5、維持費0化。"},
    {"id": "NightWork", "name": "徹夜作業", "cost": 0, "power": 0, "type": "SPELL", "desc": "AP全快。ただし手札を全て捨てる。"},
    {"id": "Complaint", "name": "近隣クレーム", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手のAPを3削る。"},
    {"id": "Boundary", "name": "境界未確定", "cost": 2, "power": 0, "type": "SPELL", "desc": "相手の機材1つを2ターン停止。"},
    {"id": "Overtime", "name": "残業指示", "cost": 0, "power": 0, "type": "SPELL", "desc": "1枚引いてAP+2。"},
    {"id": "Audit", "name": "会計検査", "cost": 4, "power": 0, "type": "SPELL", "desc": "相手の最大APを2削る。"},
    {"id": "BlueprintLoss", "name": "図面紛失", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手の手札を見て1枚捨てさせる。"},
    {"id": "DataTheft", "name": "データ盗用", "cost": 2, "power": 0, "type": "SPELL", "desc": "相手の手札をランダムに1枚捨てさせる。"},
    {"id": "AllOrNothing", "name": "一か八か", "cost": 0, "power": 0, "type": "SPELL", "desc": "コイントス。表なら5枚引く、裏なら手札全捨て＋場の機材1つランダム破壊。"},
    {"id": "Recycle", "name": "機材リサイクル", "cost": 2, "power": 0, "type": "SPELL", "desc": "破壊された機材1つを手札に戻す。"},
    {"id": "SurveyPlan", "name": "測量計画", "cost": 1, "power": 0, "type": "SPELL", "desc": "山札から3枚見て1枚を山札の一番上、残りを山札の一番下に。"},
    {"id": "EmergencyOrder", "name": "緊急発注", "cost": 3, "power": 0, "type": "SPELL", "desc": "デッキから機材を1枚サーチして手札に。"},
    {"id": "Dispatch", "name": "人材派遣", "cost": 2, "power": 0, "type": "SPELL", "desc": "デッキから社員を1枚サーチして手札に。"},
    {"id": "FullyPrepared", "name": "準備万端", "cost": 5, "power": 0, "type": "SPELL", "desc": "場に異なる5種類のカードがあれば使用可。山札から勝利カードをサーチ。"},
    {"id": "SurveyDB", "name": "測量データベース", "cost": 4, "power": 3, "type": "MACHINE", "category": "機材", "upkeep": 1, "desc": "場にいる限り、毎ターン開始時に1枚引く。"},
    {"id": "Demolition", "name": "解体工事", "cost": 4, "power": 0, "type": "SPELL", "desc": "相手の機材1つを破壊。"},
    {"id": "Layoff", "name": "リストラ", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手の人材1人を破壊。"},
    {"id": "Restructure", "name": "人員整理", "cost": 5, "power": 0, "type": "SPELL", "desc": "相手の人材を最大2人まで破壊。"},
    {"id": "Removal", "name": "設備撤去", "cost": 6, "power": 0, "type": "SPELL", "desc": "相手の機材を最大2つまで破壊。"},
    {"id": "SiteFire", "name": "現場火災", "cost": 7, "power": 0, "type": "SPELL", "desc": "相手の場のカード全てを破壊。自分の最大AP-2。"},
    {"id": "Rehire", "name": "再雇用", "cost": 2, "power": 0, "type": "SPELL", "desc": "墓地から人材1人を手札に。"},
    {"id": "Salvage", "name": "サルベージ", "cost": 4, "power": 0, "type": "SPELL", "desc": "墓地から任意のカード1枚を手札に。"},
    {"id": "Recovery", "name": "復旧作業", "cost": 5, "power": 0, "type": "SPELL", "desc": "墓地から最大2枚を手札に。"},
    {"id": "DataRestore", "name": "記録復元", "cost": 3, "power": 0, "type": "SPELL", "desc": "墓地からスペルカードを手札に。"},
    {"id": "Goal30", "name": "工期内完遂", "cost": 4, "power": 0, "type": "GOAL", "desc": "スコア30以上で勝利。"},
    {"id": "GoalFinal", "name": "社長決裁", "cost": 10, "power": 0, "type": "GOAL", "desc": "スコア10以上で勝利。"},
]

EVOLUTION_MAP = {"Staff": "Newbie", "Chief": "Staff", "LevelAuto": "LevelBasic", "StaffRef": "StaffBasic"}

class GameInstance:
    def __init__(self):
        self.reset()

    def reset(self):
        self.players = {
            "p1": {"ap": 2, "max_ap": 2, "score": 0, "hand": [], "field": [], "deck": [], "graveyard": [], "ready": False, "rush_used": False},
            "p2": {"ap": 2, "max_ap": 2, "score": 0, "hand": [], "field": [], "deck": [], "graveyard": [], "ready": False, "rush_used": False}
        }
        self.turn = "p1"
        self.turn_count = 1
        self.weather = "晴天"
        self.next_weather = None
        self.winner = None
        self.log = ["観測吝VS ULTIMATE Ver 4.1 開始！"]
        self.pending_selection = None  # {"type": "...", "player": "...", "targets": [...], "card_played": {...}}
        self.shakapachi_count = {"p1": 0, "p2": 0}  # しゃかぱちカウント

# グローバルなgameインスタンスは削除（ルーム管理に移行）

def generate_room_id():
    """4桁のルームIDを生成"""
    import string
    while True:
        room_id = ''.join(random.choices(string.digits, k=4))
        if room_id not in rooms:
            return room_id

def get_player_room(sid):
    """セッションIDからルームIDを取得"""
    return player_rooms.get(sid)

@app.route('/')
def index():
    return render_template('ultimate.html')

@socketio.on('create_room')
def handle_create_room():
    room_id = generate_room_id()
    rooms[room_id] = GameInstance()
    room_players[room_id] = {'p1': request.sid, 'p2': None}
    player_rooms[request.sid] = room_id
    join_room(room_id)
    emit('room_created', {'room_id': room_id, 'player_id': 'p1', 'waiting': True})

@socketio.on('join_room')
def handle_join_room(data):
    room_id = data.get('room_id')
    if room_id not in rooms:
        emit('error', {'message': 'ルームが存在しません'})
        return
    
    # すでに2人いる場合は拒否
    if room_players[room_id]['p2'] is not None:
        emit('error', {'message': 'ルームが満員です'})
        return
    
    # P2として参加
    room_players[room_id]['p2'] = request.sid
    player_rooms[request.sid] = room_id
    join_room(room_id)
    
    # 両方のプレイヤーに通知
    emit('room_joined', {'room_id': room_id, 'player_id': 'p2'})
    emit('room_ready', {'room_id': room_id}, room=room_id)  # 全員に準備完了を通知

@socketio.on('reset_game')
def handle_reset():
    room_id = get_player_room(request.sid)
    if not room_id or room_id not in rooms:
        return
    rooms[room_id].reset()
    emit('update_ui', vars(rooms[room_id]), room=room_id)

@socketio.on('shakapachi')
def handle_shakapachi(data):
    room_id = get_player_room(request.sid)
    if not room_id or room_id not in rooms:
        return
    game = rooms[room_id]
    
    pid = data['player_id']
    game.shakapachi_count[pid] += 1
    count = game.shakapachi_count[pid]
    
    # ログに追加
    player_name = "P1" if pid == "p1" else "P2"
    game.log.append(f"{player_name}しゃかぱち{count}回目")
    
    # 相手に通知
    opponent_pid = "p2" if pid == "p1" else "p1"
    opponent_sid = room_players[room_id][opponent_pid]
    if opponent_sid:
        emit('opponent_shakapachi', {'player_id': pid, 'count': count}, room=opponent_sid)
    
    # 全員にUIアップデート
    emit('update_ui', vars(game), room=room_id)

@socketio.on('submit_deck')
def handle_deck(data):
    room_id = get_player_room(request.sid)
    if not room_id or room_id not in rooms:
        return
    game = rooms[room_id]
    
    pid = data['player_id']
    # カードをコピーしてデッキに追加（frozen属性を初期化）
    game.players[pid]["deck"] = []
    for cid in data['deck']:
        card = dict(next(c for c in CARD_DB if c['id'] == cid))
        card['frozen'] = 0
        game.players[pid]["deck"].append(card)
    random.shuffle(game.players[pid]["deck"])
    game.players[pid]["ready"] = True
    if game.players["p1"]["ready"] and game.players["p2"]["ready"]:
        # 先攻をランダムに決定
        game.turn = random.choice(["p1", "p2"])
        game.log.append(f"先攻: {game.turn.upper()}")
        
        for p in ["p1", "p2"]:
            game.players[p]["hand"] = [game.players[p]["deck"].pop(0) for _ in range(5) if game.players[p]["deck"]]
    emit('update_ui', vars(game), room=room_id)

@socketio.on('select_target')
def handle_selection(data):
    room_id = get_player_room(request.sid)
    if not room_id or room_id not in rooms:
        return
    game = rooms[room_id]
    
    if not game.pending_selection or data['player_id'] != game.pending_selection['player']:
        return
    
    sel = game.pending_selection
    pid = sel['player']
    target_idx = data['target_index']
    
    if target_idx not in sel['targets']:
        return
    
    p = game.players[pid]
    
    if sel['type'] == 'buff_ally':
        target = p['field'][target_idx]
        target['power'] = target.get('power', 0) + 5
        target['upkeep'] = 0
        game.log.append(f"{pid.upper()}: {target['name']}を強化!")
        # 勝利判定を再度チェック
        recalc_scores(game)
        if p['score'] >= 30:
            # Goal30があれば勝利の可能性
            pass
    
    elif sel['type'] == 'destroy_enemy':
        opp = game.players[sel['target_player']]
        destroyed = opp['field'][target_idx]
        opp['field'].pop(target_idx)
        opp['graveyard'].append(destroyed)  # 墓地に送る
        game.log.append(f"{pid.upper()}: {destroyed['name']}を破壊!")
    
    elif sel['type'] == 'freeze_enemy':
        opp = game.players[sel['target_player']]
        target = opp['field'][target_idx]
        target['frozen'] = 2
        game.log.append(f"{pid.upper()}: {target['name']}を2ターン停止!")
    
    elif sel['type'] == 'sacrifice_for_upkeep':
        destroyed = p['field'][target_idx]
        p['field'].pop(target_idx)
        p['graveyard'].append(destroyed)  # 墓地に送る
        game.log.append(f"{pid.upper()}: {destroyed['name']}を破棄")
        # 再計算
        upkeep = sum(c.get('upkeep', 0) for c in p['field'])
        clerk_bonus = sum(1 for c in p['field'] if c['id'] == 'Clerk')
        p['ap'] = p['max_ap'] - upkeep + clerk_bonus
        if p['ap'] < 0 and p['field']:
            # まだ不足なら再選択
            game.pending_selection = {
                'type': 'sacrifice_for_upkeep',
                'player': pid,
                'targets': list(range(len(p['field'])))
            }
            game.log.append(f"{pid.upper()}: まだ維持費不足！さらに破棄")
            recalc_scores(game)
            emit('update_ui', vars(game), room=room_id)
            return
        # 維持費支払い完了、ドロー続行
        game.pending_selection = None
        if p['deck']: 
            p['hand'].append(p['deck'].pop(0))
        recalc_scores(game)
        emit('update_ui', vars(game), room=room_id)
        return
    
    elif sel['type'] == 'sacrifice_for_rush':
        destroyed = p['field'][target_idx]
        p['field'].pop(target_idx)
        p['graveyard'].append(destroyed)  # 墓地に送る
        game.log.append(f"{pid.upper()}: 突貫工事の反動で{destroyed['name']}が破壊")
        # Rush終了後、ターン終了処理を続行
        game.pending_selection = None
        recalc_scores(game)
        emit('update_ui', vars(game), room=room_id)
        # ターンを切り替える
        end_turn_internal(game, pid, room_id)
        return
    
    elif sel['type'] == 'discard_enemy_hand':
        # 図面紛失：相手の手札を捨てる
        opp = game.players[sel['target_player']]
        discarded = opp['hand'][target_idx]
        opp['hand'].pop(target_idx)
        game.log.append(f"{pid.upper()}: 相手の{discarded['name']}を捨てさせた!")
    
    elif sel['type'] == 'recycle_from_graveyard':
        # 機材リサイクル：墓地から手札に戻す
        recycled = p['graveyard'][target_idx]
        p['graveyard'].pop(target_idx)
        p['hand'].append(recycled)
        game.log.append(f"{pid.upper()}: {recycled['name']}を墓地から回収!")
    
    elif sel['type'] == 'survey_plan':
        # 測量計画：選んだカードを山札の一番上に
        top_cards = sel['top_cards']
        selected = top_cards[target_idx]
        # 山札の上3枚を削除
        p['deck'] = p['deck'][3:]
        # 選んだカードを一番上に
        p['deck'].insert(0, selected)
        # 残りを一番下に
        for i, card in enumerate(top_cards):
            if i != target_idx:
                p['deck'].append(card)
        game.log.append(f"{pid.upper()}: 山札を整理した!")
    
    elif sel['type'] == 'search_deck':
        # デッキサーチ：選んだカードを手札に
        searched = p['deck'][target_idx]
        p['deck'].pop(target_idx)
        p['hand'].append(searched)
        import random
        random.shuffle(p['deck'])  # デッキをシャッフル
        game.log.append(f"{pid.upper()}: {searched['name']}をサーチ!")
    
    elif sel['type'] == 'destroy_enemy_equipment':
        # 解体工事：相手の機材を破壊
        opp = game.players[sel['target_player']]
        destroyed = opp['field'][target_idx]
        opp['field'].pop(target_idx)
        opp['graveyard'].append(destroyed)
        game.log.append(f"{pid.upper()}: 相手の{destroyed['name']}を破壊!")
    
    elif sel['type'] == 'destroy_enemy_personnel':
        # リストラ：相手の人材を破壊
        opp = game.players[sel['target_player']]
        destroyed = opp['field'][target_idx]
        opp['field'].pop(target_idx)
        opp['graveyard'].append(destroyed)
        game.log.append(f"{pid.upper()}: 相手の{destroyed['name']}を解雇!")
    
    elif sel['type'] == 'destroy_multi_personnel':
        # 人員整理：複数の人材を破壊
        opp = game.players[sel['target_player']]
        destroyed = opp['field'][target_idx]
        opp['field'].pop(target_idx)
        opp['graveyard'].append(destroyed)
        sel['count'] += 1
        game.log.append(f"{pid.upper()}: 相手の{destroyed['name']}を解雇!")
        
        # まだ選択可能で、選択を続けるか確認
        if sel['count'] < sel['max_count'] and opp['field']:
            # ターゲットリストを更新（人材のみ）
            personnel = [i for i, c in enumerate(opp['field']) if c.get('category') == '人材']
            if personnel:
                sel['targets'] = personnel
                emit('update_ui', vars(game), room=room_id)
                return
    
    elif sel['type'] == 'destroy_multi_equipment':
        # 設備撤去：複数の機材を破壊
        opp = game.players[sel['target_player']]
        destroyed = opp['field'][target_idx]
        opp['field'].pop(target_idx)
        opp['graveyard'].append(destroyed)
        sel['count'] += 1
        game.log.append(f"{pid.upper()}: 相手の{destroyed['name']}を撤去!")
        
        # まだ選択可能で、選択を続けるか確認
        if sel['count'] < sel['max_count'] and opp['field']:
            # ターゲットリストを更新（機材のみ）
            machines = [i for i, c in enumerate(opp['field']) if c.get('category') == '機材']
            if machines:
                sel['targets'] = machines
                emit('update_ui', vars(game), room=room_id)
                return
    
    elif sel['type'] == 'recover_personnel':
        # 再雇用：墓地から人材を回収
        recovered = p['graveyard'][target_idx]
        p['graveyard'].pop(target_idx)
        p['hand'].append(recovered)
        game.log.append(f"{pid.upper()}: {recovered['name']}を再雇用!")
    
    elif sel['type'] == 'recover_any':
        # サルベージ：墓地から任意のカードを回収
        recovered = p['graveyard'][target_idx]
        p['graveyard'].pop(target_idx)
        p['hand'].append(recovered)
        game.log.append(f"{pid.upper()}: {recovered['name']}を回収!")
    
    elif sel['type'] == 'recover_multi':
        # 復旧作業：墓地から複数回収
        recovered = p['graveyard'][target_idx]
        p['graveyard'].pop(target_idx)
        p['hand'].append(recovered)
        sel['count'] += 1
        game.log.append(f"{pid.upper()}: {recovered['name']}を回収!")
        
        # まだ選択可能で、選択を続けるか確認
        if sel['count'] < sel['max_count'] and p['graveyard']:
            sel['targets'] = list(range(len(p['graveyard'])))
            emit('update_ui', vars(game), room=room_id)
            return
    
    elif sel['type'] == 'recover_spell':
        # 記録復元：墓地からスペルを回収
        recovered = p['graveyard'][target_idx]
        p['graveyard'].pop(target_idx)
        p['hand'].append(recovered)
        game.log.append(f"{pid.upper()}: {recovered['name']}を復元!")
    
    game.pending_selection = None
    recalc_scores(game)
    emit('update_ui', vars(game), room=room_id)

@socketio.on('play_card')
def handle_play(data):
    room_id = get_player_room(request.sid)
    if not room_id or room_id not in rooms:
        return
    game = rooms[room_id]
    
    pid, idx = data['player_id'], data['card_index']
    if pid != game.turn or game.winner: return
    p = game.players[pid]
    card = p["hand"][idx]

    # 豪雨時はスペルカード使用禁止
    if game.weather == "豪雨" and card["type"] == "SPELL":
        game.log.append(f"{pid.upper()}: スペル使用不可！(豪雨)")
        emit('update_ui', vars(game), room=room_id)
        return

    play_cost = card["cost"]
    evolve_target_idx = -1
    is_evolution = False

    if card["id"] in EVOLUTION_MAP:
        base_id = EVOLUTION_MAP[card["id"]]
        for i, f in enumerate(p["field"]):
            if f["id"] == base_id:
                play_cost, evolve_target_idx, is_evolution = 1, i, True
                break
    
    # ヘルメット効果：人材のコスト-1
    if card.get("category") == "人材":
        helmet_count = sum(1 for f in p["field"] if f["id"] == "Helmet")
        play_cost = max(0, play_cost - helmet_count)

    if p["ap"] >= play_cost:
        card = p["hand"].pop(idx)
        p["ap"] -= play_cost
        if is_evolution:
            p["field"].pop(evolve_target_idx)
            card["frozen"] = 0  # 停止状態初期化
            p["field"].append(card)
            game.log.append(f"{pid.upper()}: {card['name']} (進化召喚!)")
        else:
            if card["type"] == "MACHINE": 
                card["frozen"] = 0  # 停止状態初期化
                p["field"].append(card)
            
            # カード効果の実装
            if card["id"] == "Newbie" and p["deck"]: 
                p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Elite":
                p["max_ap"] = max(1, p["max_ap"]-1)
                for _ in range(2): 
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Fund": 
                p["max_ap"] += 1
            elif card["id"] == "Note":
                for _ in range(2):
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Check":
                for _ in range(3):
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Transceiver" and p["deck"]:
                p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Repair": 
                p["ap"] = min(p["max_ap"], p["ap"] + 5)
            elif card["id"] == "Rush": 
                p["ap"] = min(p["max_ap"], p["ap"] + 4)
                p["rush_used"] = True
                game.log.append(f"{pid.upper()}: ターン終了時に1台破壊される")
            elif card["id"] == "Decision": 
                p["max_ap"] += 2
            elif card["id"] == "Overtime":
                if p["deck"]: p["hand"].append(p["deck"].pop(0))
                p["ap"] = min(p["max_ap"], p["ap"] + 2)
            elif card["id"] == "NightWork":
                p["hand"] = []
                p["ap"] = p["max_ap"]
                # 2枚ドロー
                for _ in range(2):
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Consult":
                game.next_weather = "晴天"
                game.log.append(f"{pid.upper()}: 次ターンは晴天!")
            elif card["id"] == "Training":
                # 人材を強化（category="人材"）
                personnel = [i for i, c in enumerate(p["field"]) if c.get("category") == "人材"]
                if personnel:
                    game.pending_selection = {
                        "type": "buff_ally",
                        "player": pid,
                        "targets": personnel,
                        "card_id": "Training"
                    }
                    game.log.append(f"{pid.upper()}: 強化する人材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Safety":
                opp = game.players["p2" if pid == "p1" else "p1"]
                opp["max_ap"] = max(1, opp["max_ap"] - 1)
                game.log.append(f"{pid.upper()}: 相手の最大AP-1")
            elif card["id"] == "Lost":
                opp = game.players["p2" if pid == "p1" else "p1"]
                targets = [i for i, c in enumerate(opp["field"]) if c.get("power", 0) >= 10]
                if targets:
                    game.pending_selection = {
                        "type": "destroy_enemy",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": targets,
                        "card_id": "Lost"
                    }
                    game.log.append(f"{pid.upper()}: 紛失させる機材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Bush":
                opp = game.players["p2" if pid == "p1" else "p1"]
                targets = [i for i, c in enumerate(opp["field"]) if c.get("cost", 0) <= 2]
                if targets:
                    game.pending_selection = {
                        "type": "destroy_enemy",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": targets,
                        "card_id": "Bush"
                    }
                    game.log.append(f"{pid.upper()}: 破壊する機材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Complaint":
                opp = game.players["p2" if pid == "p1" else "p1"]
                opp["ap"] = max(0, opp["ap"] - 3)
                game.log.append(f"{pid.upper()}: 相手のAPを3削った!")
            elif card["id"] == "Boundary":
                opp = game.players["p2" if pid == "p1" else "p1"]
                if opp["field"]:
                    game.pending_selection = {
                        "type": "freeze_enemy",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": list(range(len(opp["field"]))),
                        "card_id": "Boundary"
                    }
                    game.log.append(f"{pid.upper()}: 停止する機材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Audit":
                opp = game.players["p2" if pid == "p1" else "p1"]
                opp["max_ap"] = max(1, opp["max_ap"] - 2)
                game.log.append(f"{pid.upper()}: 相手の最大APを2削った!")
            elif card["id"] == "BlueprintLoss":
                # 図面紛失：相手の手札を見て1枚捨てさせる
                opp = game.players["p2" if pid == "p1" else "p1"]
                if opp["hand"]:
                    game.pending_selection = {
                        "type": "discard_enemy_hand",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": list(range(len(opp["hand"]))),
                        "card_id": "BlueprintLoss"
                    }
                    game.log.append(f"{pid.upper()}: 相手の手札を見て1枚選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "DataTheft":
                # データ盗用：相手の手札をランダムに1枚捨てさせる
                opp = game.players["p2" if pid == "p1" else "p1"]
                if opp["hand"]:
                    import random
                    discarded = opp["hand"].pop(random.randint(0, len(opp["hand"]) - 1))
                    game.log.append(f"{pid.upper()}: {discarded['name']}を盗んで捨てた!")
            elif card["id"] == "AllOrNothing":
                # 一か八か：コイントス
                import random
                result = random.choice([True, False])
                if result:  # 表
                    for _ in range(5):
                        if p["deck"]: p["hand"].append(p["deck"].pop(0))
                    game.log.append(f"{pid.upper()}: コイントス成功！5枚引いた!")
                else:  # 裏
                    p["hand"] = []
                    if p["field"]:
                        destroyed_idx = random.randint(0, len(p["field"]) - 1)
                        destroyed = p["field"].pop(destroyed_idx)
                        p["graveyard"].append(destroyed)
                        game.log.append(f"{pid.upper()}: コイントス失敗！手札全捨て＋{destroyed['name']}破壊!")
                    else:
                        game.log.append(f"{pid.upper()}: コイントス失敗！手札全捨て!")
            elif card["id"] == "Recycle":
                # 機材リサイクル：墓地から機材を1つ手札に戻す
                graveyard_machines = [i for i, c in enumerate(p["graveyard"]) if c.get("category") == "機材"]
                if graveyard_machines:
                    game.pending_selection = {
                        "type": "recycle_from_graveyard",
                        "player": pid,
                        "targets": graveyard_machines,
                        "card_id": "Recycle"
                    }
                    game.log.append(f"{pid.upper()}: 墓地から機材を1つ選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "SurveyPlan":
                # 測量計画：山札から3枚見て1枚を山札の一番上、残りを山札の一番下に
                if len(p["deck"]) >= 3:
                    game.pending_selection = {
                        "type": "survey_plan",
                        "player": pid,
                        "targets": [0, 1, 2],
                        "top_cards": [p["deck"][0], p["deck"][1], p["deck"][2]],
                        "card_id": "SurveyPlan"
                    }
                    game.log.append(f"{pid.upper()}: 山札の上3枚から1枚選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "EmergencyOrder":
                # 緊急発注：デッキから機材を1枚サーチ
                machines = [i for i, c in enumerate(p["deck"]) if c.get("category") == "機材"]
                if machines:
                    game.pending_selection = {
                        "type": "search_deck",
                        "player": pid,
                        "targets": machines,
                        "card_id": "EmergencyOrder"
                    }
                    game.log.append(f"{pid.upper()}: デッキから機材を1枚選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Dispatch":
                # 人材派遣：デッキから人材を1枚サーチ
                personnel = [i for i, c in enumerate(p["deck"]) if c.get("category") == "人材"]
                if personnel:
                    game.pending_selection = {
                        "type": "search_deck",
                        "player": pid,
                        "targets": personnel,
                        "card_id": "Dispatch"
                    }
                    game.log.append(f"{pid.upper()}: デッキから人材を1枚選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "FullyPrepared":
                # 準備万端：場に異なる5種類のカードがあればデッキから勝利カードをサーチ
                unique_cards = set(c["id"] for c in p["field"])
                if len(unique_cards) >= 5:
                    goals = [i for i, c in enumerate(p["deck"]) if c["type"] == "GOAL"]
                    if goals:
                        game.pending_selection = {
                            "type": "search_deck",
                            "player": pid,
                            "targets": goals,
                            "card_id": "FullyPrepared"
                        }
                        game.log.append(f"{pid.upper()}: デッキから勝利カードを1枚選んでください")
                        emit('update_ui', vars(game), room=room_id)
                        return
                else:
                    game.log.append(f"{pid.upper()}: 場のカード種類が不足！({len(unique_cards)}/5)")
            elif card["id"] == "Demolition":
                # 解体工事：相手の機材1つを破壊
                opp = game.players["p2" if pid == "p1" else "p1"]
                machines = [i for i, c in enumerate(opp["field"]) if c.get("category") == "機材"]
                if machines:
                    game.pending_selection = {
                        "type": "destroy_enemy_equipment",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": machines,
                        "card_id": "Demolition"
                    }
                    game.log.append(f"{pid.upper()}: 破壊する相手の機材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Layoff":
                # リストラ：相手の人材1人を破壊
                opp = game.players["p2" if pid == "p1" else "p1"]
                personnel = [i for i, c in enumerate(opp["field"]) if c.get("category") == "人材"]
                if personnel:
                    game.pending_selection = {
                        "type": "destroy_enemy_personnel",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": personnel,
                        "card_id": "Layoff"
                    }
                    game.log.append(f"{pid.upper()}: 破壊する相手の人材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Restructure":
                # 人員整理：相手の人材を最大2人まで破壊
                opp = game.players["p2" if pid == "p1" else "p1"]
                personnel = [i for i, c in enumerate(opp["field"]) if c.get("category") == "人材"]
                if personnel:
                    game.pending_selection = {
                        "type": "destroy_multi_personnel",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": personnel,
                        "count": 0,
                        "max_count": min(2, len(personnel)),
                        "card_id": "Restructure"
                    }
                    game.log.append(f"{pid.upper()}: 破壊する人材を選んでください（最大2人）")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Removal":
                # 設備撤去：相手の機材を最大2つまで破壊
                opp = game.players["p2" if pid == "p1" else "p1"]
                machines = [i for i, c in enumerate(opp["field"]) if c.get("category") == "機材"]
                if machines:
                    game.pending_selection = {
                        "type": "destroy_multi_equipment",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": machines,
                        "count": 0,
                        "max_count": min(2, len(machines)),
                        "card_id": "Removal"
                    }
                    game.log.append(f"{pid.upper()}: 破壊する機材を選んでください（最大2つ）")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "SiteFire":
                # 現場火災：相手の場のカード全てを破壊、自分の最大AP-2
                opp = game.players["p2" if pid == "p1" else "p1"]
                destroyed_count = len(opp["field"])
                for c in opp["field"]:
                    opp["graveyard"].append(c)
                opp["field"] = []
                p["max_ap"] = max(1, p["max_ap"] - 2)
                game.log.append(f"{pid.upper()}: 現場火災で相手の場を全滅させた！（{destroyed_count}枚破壊）")
                game.log.append(f"{pid.upper()}: 自分の最大AP-2")
            elif card["id"] == "Rehire":
                # 再雇用：墓地から人材1人を手札に
                personnel = [i for i, c in enumerate(p["graveyard"]) if c.get("category") == "人材"]
                if personnel:
                    game.pending_selection = {
                        "type": "recover_personnel",
                        "player": pid,
                        "targets": personnel,
                        "card_id": "Rehire"
                    }
                    game.log.append(f"{pid.upper()}: 回収する人材を選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Salvage":
                # サルベージ：墓地から任意のカード1枚を手札に
                if p["graveyard"]:
                    game.pending_selection = {
                        "type": "recover_any",
                        "player": pid,
                        "targets": list(range(len(p["graveyard"]))),
                        "card_id": "Salvage"
                    }
                    game.log.append(f"{pid.upper()}: 回収するカードを選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "Recovery":
                # 復旧作業：墓地から最大2枚を手札に
                if p["graveyard"]:
                    game.pending_selection = {
                        "type": "recover_multi",
                        "player": pid,
                        "targets": list(range(len(p["graveyard"]))),
                        "count": 0,
                        "max_count": min(2, len(p["graveyard"])),
                        "card_id": "Recovery"
                    }
                    game.log.append(f"{pid.upper()}: 回収するカードを選んでください（最大2枚）")
                    emit('update_ui', vars(game), room=room_id)
                    return
            elif card["id"] == "DataRestore":
                # 記録復元：墓地からスペルカードを手札に
                spells = [i for i, c in enumerate(p["graveyard"]) if c["type"] == "SPELL"]
                if spells:
                    game.pending_selection = {
                        "type": "recover_spell",
                        "player": pid,
                        "targets": spells,
                        "card_id": "DataRestore"
                    }
                    game.log.append(f"{pid.upper()}: 回収するスペルを選んでください")
                    emit('update_ui', vars(game), room=room_id)
                    return

            # 通常のログ記録（進化以外）
            if not is_evolution:
                game.log.append(f"{pid.upper()}: {card['name']}")
        
        # 勝利条件判定
        if card["id"] == "GoalFinal" and p["score"] >= 10: 
            game.winner = pid
            game.log.append(f"{pid.upper()}: 社長決裁で勝利!")
        if card["id"] == "Goal30" and p["score"] >= 30: 
            game.winner = pid
            game.log.append(f"{pid.upper()}: 工期完遂で勝利!")
        recalc_scores(game)
    emit('update_ui', vars(game), room=room_id)

def recalc_scores(game):
    for pid in ["p1", "p2"]:
        p = game.players[pid]
        s = 0
        
        # フィールドの補助カードをチェック
        has_senior = any(c["id"] == "Senior" for c in p["field"])
        has_genset = any(c["id"] == "GenSet" for c in p["field"])
        has_radio = any(c["id"] == "Radio" for c in p["field"])
        has_pump = any(c["id"] == "Pump" for c in p["field"])
        
        for c in p["field"]:
            # 停止中のカードはパワー0
            if c.get("frozen", 0) > 0:
                continue
            
            v = c["power"]
            
            # Senior効果: 新入社員のパワー+3
            if has_senior and c["id"] == "Newbie": v += 3
            
            # GenSet効果: 他機材のパワー+2（自身以外のMACHINE）
            if has_genset and c["id"] != "GenSet" and c["type"] == "MACHINE": v += 2
            
            # Radio効果: ドローンを強化+3
            if has_radio and c["id"] == "Drone": v += 3
            
            # Lights効果: 後半（ターン6以降）でパワー+4
            if c["id"] == "Lights" and game.turn_count >= 6: v += 4
            
            # GNSS: 晴天時+5
            if c["id"] == "GNSS" and game.weather == "晴天": v += 5
            
            # 濃霧: ドローン以外半減
            if game.weather == "濃霧" and c["id"] != "Drone": v //= 2
            
            # 豪雨: 生コン-5（ただしPumpがあれば無効化）
            if game.weather == "豪雨" and c["id"] == "Concrete":
                if not has_pump: v -= 5
            
            s += max(0, v)
        
        p["score"] = s

@socketio.on('end_turn')
def end_turn(data):
    room_id = get_player_room(request.sid)
    if not room_id or room_id not in rooms:
        return
    game = rooms[room_id]
    
    if data['player_id'] != game.turn or game.winner: return
    
    # Rush効果: 自分のターン終了時に場の1台を破壊
    current_player = game.players[game.turn]
    if current_player.get("rush_used") and current_player["field"]:
        game.pending_selection = {
            "type": "sacrifice_for_rush",
            "player": game.turn,
            "targets": list(range(len(current_player["field"])))
        }
        current_player["rush_used"] = False
        game.log.append(f"{game.turn.upper()}: 突貫工事の反動！破壊するカードを選んでください")
        emit('update_ui', vars(game), room=room_id)
        return
    
    end_turn_internal(game, data['player_id'], room_id)

def end_turn_internal(game, player_id, room_id):
    """ターン終了の内部処理（選択処理後にも呼ばれる）"""
    game.turn = "p2" if game.turn == "p1" else "p1"
    
    # P1のターン開始時に天候と日付を更新
    if game.turn == "p1":
        game.turn_count += 1
        # Consult効果で予約された天候があればそれを使用
        if game.next_weather:
            game.weather = game.next_weather
            game.next_weather = None
        else:
            game.weather = random.choice(["晴天", "晴天", "豪雨", "濃霧"])
        game.log.append(f"--- Day {game.turn_count} 天候: {game.weather} ---")
    
    p = game.players[game.turn]
    
    # 停止カウンターを減少
    for c in p["field"]:
        if c.get("frozen", 0) > 0:
            c["frozen"] -= 1
            if c["frozen"] == 0:
                game.log.append(f"{game.turn.upper()}: {c['name']}が復帰!")
    
    p["max_ap"] = min(p["max_ap"] + 1, 15)
    
    # 維持費計算 (事務員ボーナス含む)
    upkeep = sum(c.get("upkeep", 0) for c in p["field"])
    clerk_bonus = sum(1 for c in p["field"] if c["id"] == "Clerk")
    p["ap"] = min(p["max_ap"], p["max_ap"] - upkeep + clerk_bonus)
    
    # APがマイナスの場合、プレイヤーに選択させる
    if p["ap"] < 0 and p["field"]:
        game.pending_selection = {
            "type": "sacrifice_for_upkeep",
            "player": game.turn,
            "targets": list(range(len(p["field"])))
        }
        game.log.append(f"{game.turn.upper()}: 維持費不足！破棄するカードを選んでください")
        emit('update_ui', vars(game), room=room_id)
        return
    
    # ドローフェーズ
    if p["deck"]: 
        p["hand"].append(p["deck"].pop(0))
    
    # 測量データベースの効果：場にあれば追加ドロー
    if any(c["id"] == "SurveyDB" for c in p["field"]):
        if p["deck"]:
            p["hand"].append(p["deck"].pop(0))
            game.log.append(f"{game.turn.upper()}: 測量データベースで追加ドロー!")
    
    recalc_scores(game)
    emit('update_ui', vars(game), room=room_id)

if __name__ == '__main__':
    socketio.run(app, debug=True, host='0.0.0.0', port=5000)
