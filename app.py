# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17xMLrQtghyYz1mFwe2gEQHcTT_rCykc7
"""

import random
from flask import Flask, render_template
from flask_socketio import SocketIO, emit

app = Flask(__name__)
app.config['SECRET_KEY'] = 'kanzoku-kun-v3.1-ultimate'
socketio = SocketIO(app)

# --- 55種類のカードデータベース ---
CARD_DB = [
    {"id": "Newbie", "name": "新入社員", "cost": 1, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "【登場時】1枚引く。"},
    {"id": "Staff", "name": "担当社員", "cost": 3, "power": 4, "type": "MACHINE", "upkeep": 1, "desc": "新入社員から進化(1)。"},
    {"id": "Chief", "name": "主任技術者", "cost": 5, "power": 8, "type": "MACHINE", "upkeep": 0, "desc": "担当社員から進化(1)。維持費0。"},
    {"id": "Senior", "name": "教育係の先輩", "cost": 2, "power": 3, "type": "MACHINE", "upkeep": 1, "desc": "新入社員のパワー+3。"},
    {"id": "Ace", "name": "現場のエース", "cost": 4, "power": 12, "type": "MACHINE", "upkeep": 2, "desc": "高出力な現場員。"},
    {"id": "Leader", "name": "現場代理人", "cost": 6, "power": 15, "type": "MACHINE", "upkeep": 1, "desc": "パワーが高いが低維持費。"},
    {"id": "Expert", "name": "ベテラン職人", "cost": 5, "power": 10, "type": "MACHINE", "upkeep": 2, "desc": "安定した計測値。"},
    {"id": "Clerk", "name": "事務員", "cost": 2, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "毎ターンAP+1回復。"},
    {"id": "Intern", "name": "実習生", "cost": 0, "power": 0, "type": "MACHINE", "upkeep": 0, "desc": "コスト0の囮。"},
    {"id": "SafetyOfficer", "name": "安全管理員", "cost": 3, "power": 2, "type": "MACHINE", "upkeep": 1, "desc": "現場の守り神。"},
    {"id": "LevelBasic", "name": "普通のレベル", "cost": 1, "power": 2, "type": "MACHINE", "upkeep": 1, "desc": "基本機材。"},
    {"id": "LevelAuto", "name": "オートレベル", "cost": 3, "power": 6, "type": "MACHINE", "upkeep": 1, "desc": "普通レベルから進化(1)。"},
    {"id": "StaffBasic", "name": "アルミスタッフ", "cost": 1, "power": 2, "type": "MACHINE", "upkeep": 1, "desc": "基本スタッフ。"},
    {"id": "StaffRef", "name": "反射スタッフ", "cost": 3, "power": 7, "type": "MACHINE", "upkeep": 1, "desc": "アルミから進化(1)。"},
    {"id": "TS", "name": "光波TS", "cost": 4, "power": 10, "type": "MACHINE", "upkeep": 2, "desc": "主力機材。"},
    {"id": "GNSS", "name": "GNSS衛星", "cost": 6, "power": 18, "type": "MACHINE", "upkeep": 3, "desc": "晴天時パワー+5。"},
    {"id": "Drone", "name": "UAVドローン", "cost": 5, "power": 14, "type": "MACHINE", "upkeep": 2, "desc": "濃霧の影響を受けない。"},
    {"id": "Scanner", "name": "3Dスキャナ", "cost": 8, "power": 25, "type": "MACHINE", "upkeep": 3, "desc": "最高クラスの出力。"},
    {"id": "UsedTS", "name": "中古のTS", "cost": 2, "power": 12, "type": "MACHINE", "upkeep": 2, "desc": "安価だが維持費がかさむ。"},
    {"id": "Laser", "name": "レーザー墨出し", "cost": 2, "power": 5, "type": "MACHINE", "upkeep": 1, "desc": "室内で真価を発揮。"},
    {"id": "Compass", "name": "コンパス", "cost": 1, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "方位を計測。"},
    {"id": "Tripod", "name": "三脚", "cost": 1, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "機材の土台。"},
    {"id": "Caliper", "name": "ノギス", "cost": 1, "power": 2, "type": "MACHINE", "upkeep": 1, "desc": "精密計測。"},
    {"id": "Scale", "name": "スケール", "cost": 1, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "基本。"},
    {"id": "Chalk", "name": "チョーク", "cost": 1, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "マーキング用。"},
    {"id": "Excavator", "name": "バックホー", "cost": 7, "power": 20, "type": "MACHINE", "upkeep": 4, "desc": "圧倒的パワー。"},
    {"id": "Rental", "name": "レンタル重機", "cost": 3, "power": 15, "type": "MACHINE", "upkeep": 5, "desc": "維持費が非常に高い。"},
    {"id": "SmallTruck", "name": "軽トラ", "cost": 2, "power": 1, "type": "MACHINE", "upkeep": 0, "desc": "設置をスムーズにする。"},
    {"id": "Concrete", "name": "生コン車", "cost": 5, "power": 10, "type": "MACHINE", "upkeep": 3, "desc": "雨天時パワー-5。"},
    {"id": "Pump", "name": "排水ポンプ", "cost": 3, "power": 0, "type": "MACHINE", "upkeep": 1, "desc": "豪雨のマイナスを無効化。"},
    {"id": "GenSet", "name": "発電機", "cost": 3, "power": 3, "type": "MACHINE", "upkeep": 1, "desc": "他機材のパワー+2。"},
    {"id": "Radio", "name": "無線機", "cost": 2, "power": 2, "type": "MACHINE", "upkeep": 1, "desc": "ドローンを強化。"},
    {"id": "Lights", "name": "投光器", "cost": 3, "power": 4, "type": "MACHINE", "upkeep": 1, "desc": "後半でパワーアップ。"},
    {"id": "Helmet", "name": "ヘルメット", "cost": 1, "power": 0, "type": "MACHINE", "upkeep": 0, "desc": "社員コストを軽減。"},
    {"id": "Barrier", "name": "工事看板", "cost": 2, "power": 0, "type": "MACHINE", "upkeep": 1, "desc": "相手の行動を抑制。"},
    {"id": "Elite", "name": "少数精鋭", "cost": 2, "power": 0, "type": "SPELL", "desc": "最大AP-1。2枚引く。"},
    {"id": "Decision", "name": "苦渋の決断", "cost": 0, "power": 0, "type": "SPELL", "desc": "手札から強カードを捨て最大AP+2。"},
    {"id": "Fund", "name": "資金調達", "cost": 4, "power": 0, "type": "SPELL", "desc": "永久に最大AP+1。"},
    {"id": "Transceiver", "name": "トランシーバー", "cost": 1, "power": 0, "type": "SPELL", "desc": "デッキから1枚引く。"},
    {"id": "Safety", "name": "安全巡回", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手の最大AP-1。"},
    {"id": "Lost", "name": "紛失事故", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手のパワー10以上を1台破壊。"},
    {"id": "Note", "name": "電子野帳", "cost": 1, "power": 0, "type": "SPELL", "desc": "カードを2枚引く。"},
    {"id": "Repair", "name": "緊急修理", "cost": 2, "power": 0, "type": "SPELL", "desc": "APを5回復する。"},
    {"id": "Check", "name": "Wチェック", "cost": 2, "power": 0, "type": "SPELL", "desc": "カードを3枚引く。"},
    {"id": "Bush", "name": "藪払い", "cost": 2, "power": 0, "type": "SPELL", "desc": "相手の低コスト機を破壊。"},
    {"id": "Rush", "name": "突貫工事", "cost": 0, "power": 0, "type": "SPELL", "desc": "このターンAP+4。終了時、場の1台自壊。"},
    {"id": "Consult", "name": "気象予報", "cost": 1, "power": 0, "type": "SPELL", "desc": "次ターンの天候を晴天にする。"},
    {"id": "Training", "name": "資格手当", "cost": 2, "power": 0, "type": "SPELL", "desc": "社員1人のパワー+5、維持費0化。"},
    {"id": "NightWork", "name": "徹夜作業", "cost": 0, "power": 0, "type": "SPELL", "desc": "AP全快。ただし手札を全て捨てる。"},
    {"id": "Complaint", "name": "近隣クレーム", "cost": 3, "power": 0, "type": "SPELL", "desc": "相手のAPを3削る。"},
    {"id": "Boundary", "name": "境界未確定", "cost": 2, "power": 0, "type": "SPELL", "desc": "相手の機材1つを2ターン停止。"},
    {"id": "Overtime", "name": "残業指示", "cost": 0, "power": 0, "type": "SPELL", "desc": "1枚引いてAP+2。"},
    {"id": "Audit", "name": "会計検査", "cost": 4, "power": 0, "type": "SPELL", "desc": "相手の最大APを2削る。"},
    {"id": "Goal30", "name": "工期内完遂", "cost": 4, "power": 0, "type": "GOAL", "desc": "スコア30以上で勝利。"},
    {"id": "GoalFinal", "name": "社長決裁", "cost": 10, "power": 0, "type": "GOAL", "desc": "スコア10以上で勝利。"},
]

EVOLUTION_MAP = {"Staff": "Newbie", "Chief": "Staff", "LevelAuto": "LevelBasic", "StaffRef": "StaffBasic"}

class GameInstance:
    def __init__(self):
        self.reset()

    def reset(self):
        self.players = {
            "p1": {"ap": 2, "max_ap": 2, "score": 0, "hand": [], "field": [], "deck": [], "ready": False, "rush_used": False},
            "p2": {"ap": 2, "max_ap": 2, "score": 0, "hand": [], "field": [], "deck": [], "ready": False, "rush_used": False}
        }
        self.turn = "p1"
        self.turn_count = 1
        self.weather = "晴天"
        self.next_weather = None
        self.winner = None
        self.log = ["観測君VS ULTIMATE Ver 3.1 開始！"]
        self.pending_selection = None  # {"type": "...", "player": "...", "targets": [...], "card_played": {...}}

game = GameInstance()

@app.route('/')
def index():
    return render_template('ultimate.html')

@socketio.on('reset_game')
def handle_reset():
    game.reset()
    emit('update_ui', vars(game), broadcast=True)

@socketio.on('submit_deck')
def handle_deck(data):
    pid = data['player_id']
    # カードをコピーしてデッキに追加（frozen属性を初期化）
    game.players[pid]["deck"] = []
    for cid in data['deck']:
        card = dict(next(c for c in CARD_DB if c['id'] == cid))
        card['frozen'] = 0
        game.players[pid]["deck"].append(card)
    random.shuffle(game.players[pid]["deck"])
    game.players[pid]["ready"] = True
    if game.players["p1"]["ready"] and game.players["p2"]["ready"]:
        for p in ["p1", "p2"]:
            game.players[p]["hand"] = [game.players[p]["deck"].pop(0) for _ in range(5) if game.players[p]["deck"]]
    emit('update_ui', vars(game), broadcast=True)

@socketio.on('select_target')
def handle_selection(data):
    if not game.pending_selection or data['player_id'] != game.pending_selection['player']:
        return
    
    sel = game.pending_selection
    pid = sel['player']
    target_idx = data['target_index']
    
    if target_idx not in sel['targets']:
        return
    
    p = game.players[pid]
    
    if sel['type'] == 'buff_ally':
        target = p['field'][target_idx]
        target['power'] = target.get('power', 0) + 5
        target['upkeep'] = 0
        game.log.append(f"{pid.upper()}: {target['name']}を強化!")
        # 勝利判定を再度チェック
        recalc_scores()
        if p['score'] >= 30:
            # Goal30があれば勝利の可能性
            pass
    
    elif sel['type'] == 'destroy_enemy':
        opp = game.players[sel['target_player']]
        destroyed = opp['field'][target_idx]
        opp['field'].pop(target_idx)
        game.log.append(f"{pid.upper()}: {destroyed['name']}を破壊!")
    
    elif sel['type'] == 'freeze_enemy':
        opp = game.players[sel['target_player']]
        target = opp['field'][target_idx]
        target['frozen'] = 2
        game.log.append(f"{pid.upper()}: {target['name']}を2ターン停止!")
    
    elif sel['type'] == 'sacrifice_for_upkeep':
        destroyed = p['field'][target_idx]
        p['field'].pop(target_idx)
        game.log.append(f"{pid.upper()}: {destroyed['name']}を破棄")
        # 再計算
        upkeep = sum(c.get('upkeep', 0) for c in p['field'])
        clerk_bonus = sum(1 for c in p['field'] if c['id'] == 'Clerk')
        p['ap'] = p['max_ap'] - upkeep + clerk_bonus
        if p['ap'] < 0 and p['field']:
            # まだ不足なら再選択
            game.pending_selection = {
                'type': 'sacrifice_for_upkeep',
                'player': pid,
                'targets': list(range(len(p['field'])))
            }
            game.log.append(f"{pid.upper()}: まだ維持費不足！さらに破棄")
            recalc_scores()
            emit('update_ui', vars(game), broadcast=True)
            return
        # 維持費支払い完了、ドロー続行
        game.pending_selection = None
        if p['deck']: 
            p['hand'].append(p['deck'].pop(0))
        recalc_scores()
        emit('update_ui', vars(game), broadcast=True)
        return
    
    elif sel['type'] == 'sacrifice_for_rush':
        destroyed = p['field'][target_idx]
        p['field'].pop(target_idx)
        game.log.append(f"{pid.upper()}: 突貫工事の反動で{destroyed['name']}が破壊")
        # Rush終了後、ターン終了処理を続行
        game.pending_selection = None
        recalc_scores()
        emit('update_ui', vars(game), broadcast=True)
        # ターンを切り替える
        end_turn_internal(pid)
        return
    
    game.pending_selection = None
    recalc_scores()
    emit('update_ui', vars(game), broadcast=True)

@socketio.on('play_card')
def handle_play(data):
    pid, idx = data['player_id'], data['card_index']
    if pid != game.turn or game.winner: return
    p = game.players[pid]
    card = p["hand"][idx]

    # 豪雨時はスペルカード使用禁止
    if game.weather == "豪雨" and card["type"] == "SPELL":
        game.log.append(f"{pid.upper()}: スペル使用不可！(豪雨)")
        emit('update_ui', vars(game), broadcast=True)
        return

    play_cost = card["cost"]
    evolve_target_idx = -1
    is_evolution = False

    if card["id"] in EVOLUTION_MAP:
        base_id = EVOLUTION_MAP[card["id"]]
        for i, f in enumerate(p["field"]):
            if f["id"] == base_id:
                play_cost, evolve_target_idx, is_evolution = 1, i, True
                break

    if p["ap"] >= play_cost:
        card = p["hand"].pop(idx)
        p["ap"] -= play_cost
        if is_evolution:
            p["field"].pop(evolve_target_idx)
            card["frozen"] = 0  # 停止状態初期化
            p["field"].append(card)
            game.log.append(f"{pid.upper()}: {card['name']} (進化召喚!)")
        else:
            if card["type"] == "MACHINE": 
                card["frozen"] = 0  # 停止状態初期化
                p["field"].append(card)
            
            # カード効果の実装
            if card["id"] == "Newbie" and p["deck"]: 
                p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Elite":
                p["max_ap"] = max(1, p["max_ap"]-1)
                for _ in range(2): 
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Fund": 
                p["max_ap"] += 1
            elif card["id"] == "Note":
                for _ in range(2):
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Check":
                for _ in range(3):
                    if p["deck"]: p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Transceiver" and p["deck"]:
                p["hand"].append(p["deck"].pop(0))
            elif card["id"] == "Repair": 
                p["ap"] = min(p["max_ap"], p["ap"] + 5)
            elif card["id"] == "Rush": 
                p["ap"] += 4
                p["rush_used"] = True
                game.log.append(f"{pid.upper()}: ターン終了時に1台破壊される")
            elif card["id"] == "Decision": 
                p["max_ap"] += 2
            elif card["id"] == "Overtime":
                if p["deck"]: p["hand"].append(p["deck"].pop(0))
                p["ap"] += 2
            elif card["id"] == "NightWork":
                p["hand"] = []
                p["ap"] = p["max_ap"]
            elif card["id"] == "Consult":
                game.next_weather = "晴天"
                game.log.append(f"{pid.upper()}: 次ターンは晴天!")
            elif card["id"] == "Training":
                # 社員カードのみを対象とする
                employee_ids = ["Newbie", "Staff", "Chief", "Senior", "Ace", "Leader", "Expert", "Clerk", "Intern", "SafetyOfficer"]
                employee_targets = [i for i, c in enumerate(p["field"]) if c["id"] in employee_ids]
                if employee_targets:
                    game.pending_selection = {
                        "type": "buff_ally",
                        "player": pid,
                        "targets": employee_targets,
                        "card_id": "Training"
                    }
                    game.log.append(f"{pid.upper()}: 強化する社員を選んでください")
                    emit('update_ui', vars(game), broadcast=True)
                    return
            elif card["id"] == "Safety":
                opp = game.players["p2" if pid == "p1" else "p1"]
                opp["max_ap"] = max(1, opp["max_ap"] - 1)
                game.log.append(f"{pid.upper()}: 相手の最大AP-1")
            elif card["id"] == "Lost":
                opp = game.players["p2" if pid == "p1" else "p1"]
                targets = [i for i, c in enumerate(opp["field"]) if c.get("power", 0) >= 10]
                if targets:
                    game.pending_selection = {
                        "type": "destroy_enemy",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": targets,
                        "card_id": "Lost"
                    }
                    game.log.append(f"{pid.upper()}: 紛失させる機材を選んでください")
                    emit('update_ui', vars(game), broadcast=True)
                    return
            elif card["id"] == "Bush":
                opp = game.players["p2" if pid == "p1" else "p1"]
                targets = [i for i, c in enumerate(opp["field"]) if c.get("cost", 0) <= 2]
                if targets:
                    game.pending_selection = {
                        "type": "destroy_enemy",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": targets,
                        "card_id": "Bush"
                    }
                    game.log.append(f"{pid.upper()}: 破壊する機材を選んでください")
                    emit('update_ui', vars(game), broadcast=True)
                    return
            elif card["id"] == "Complaint":
                opp = game.players["p2" if pid == "p1" else "p1"]
                opp["ap"] = max(0, opp["ap"] - 3)
                game.log.append(f"{pid.upper()}: 相手のAPを3削った!")
            elif card["id"] == "Boundary":
                opp = game.players["p2" if pid == "p1" else "p1"]
                if opp["field"]:
                    game.pending_selection = {
                        "type": "freeze_enemy",
                        "player": pid,
                        "target_player": "p2" if pid == "p1" else "p1",
                        "targets": list(range(len(opp["field"]))),
                        "card_id": "Boundary"
                    }
                    game.log.append(f"{pid.upper()}: 停止する機材を選んでください")
                    emit('update_ui', vars(game), broadcast=True)
                    return
            elif card["id"] == "Audit":
                opp = game.players["p2" if pid == "p1" else "p1"]
                opp["max_ap"] = max(1, opp["max_ap"] - 2)
                game.log.append(f"{pid.upper()}: 相手の最大APを2削った!")

            # 通常のログ記録（進化以外）
            if not is_evolution:
                game.log.append(f"{pid.upper()}: {card['name']}")
        
        # スコア再計算してから勝利条件判定
        recalc_scores()
        
        # 勝利条件判定
        if card["id"] == "GoalFinal" and p["score"] >= 10: 
            game.winner = pid
            game.log.append(f"{pid.upper()}: 社長決裁で勝利!")
        if card["id"] == "Goal30" and p["score"] >= 30: 
            game.winner = pid
            game.log.append(f"{pid.upper()}: 工期完遂で勝利!")
    emit('update_ui', vars(game), broadcast=True)

def recalc_scores():
    for pid in ["p1", "p2"]:
        p = game.players[pid]
        s = 0
        
        # フィールドの補助カードをチェック
        has_senior = any(c["id"] == "Senior" for c in p["field"])
        has_genset = any(c["id"] == "GenSet" for c in p["field"])
        has_radio = any(c["id"] == "Radio" for c in p["field"])
        has_pump = any(c["id"] == "Pump" for c in p["field"])
        
        for c in p["field"]:
            # 停止中のカードはパワー0
            if c.get("frozen", 0) > 0:
                continue
            
            v = c["power"]
            
            # Senior効果: 新入社員のパワー+3
            if has_senior and c["id"] == "Newbie": v += 3
            
            # GenSet効果: 他機材のパワー+2（自身以外のMACHINE）
            if has_genset and c["id"] != "GenSet" and c["type"] == "MACHINE": v += 2
            
            # Radio効果: ドローンを強化+3
            if has_radio and c["id"] == "Drone": v += 3
            
            # Lights効果: 後半（ターン6以降）でパワー+4
            if c["id"] == "Lights" and game.turn_count >= 6: v += 4
            
            # GNSS: 晴天時+5
            if c["id"] == "GNSS" and game.weather == "晴天": v += 5
            
            # 濃霧: ドローン以外半減
            if game.weather == "濃霧" and c["id"] != "Drone": v //= 2
            
            # 豪雨: 生コン-5（ただしPumpがあれば無効化）
            if game.weather == "豪雨" and c["id"] == "Concrete":
                if not has_pump: v -= 5
            
            s += max(0, v)
        
        p["score"] = s

@socketio.on('end_turn')
def end_turn(data):
    if data['player_id'] != game.turn or game.winner: return
    
    # Rush効果: 自分のターン終了時に場の1台を破壊
    current_player = game.players[game.turn]
    if current_player.get("rush_used") and current_player["field"]:
        game.pending_selection = {
            "type": "sacrifice_for_rush",
            "player": game.turn,
            "targets": list(range(len(current_player["field"])))
        }
        current_player["rush_used"] = False
        game.log.append(f"{game.turn.upper()}: 突貫工事の反動！破壊するカードを選んでください")
        emit('update_ui', vars(game), broadcast=True)
        return
    
    end_turn_internal(data['player_id'])

def end_turn_internal(player_id):
    """ターン終了の内部処理（選択処理後にも呼ばれる）"""
    game.turn = "p2" if game.turn == "p1" else "p1"
    
    # P1のターン開始時に天候と日付を更新
    if game.turn == "p1":
        game.turn_count += 1
        # Consult効果で予約された天候があればそれを使用
        if game.next_weather:
            game.weather = game.next_weather
            game.next_weather = None
        else:
            game.weather = random.choice(["晴天", "晴天", "豪雨", "濃霧"])
        game.log.append(f"--- Day {game.turn_count} 天候: {game.weather} ---")
    
    p = game.players[game.turn]
    
    # 停止カウンターを減少
    for c in p["field"]:
        if c.get("frozen", 0) > 0:
            c["frozen"] -= 1
            if c["frozen"] == 0:
                game.log.append(f"{game.turn.upper()}: {c['name']}が復帰!")
    
    p["max_ap"] = min(p["max_ap"] + 1, 15)
    
    # 維持費計算 (事務員ボーナス含む)
    upkeep = sum(c.get("upkeep", 0) for c in p["field"])
    clerk_bonus = sum(1 for c in p["field"] if c["id"] == "Clerk")
    p["ap"] = p["max_ap"] - upkeep + clerk_bonus
    
    # APがマイナスの場合、プレイヤーに選択させる
    if p["ap"] < 0 and p["field"]:
        game.pending_selection = {
            "type": "sacrifice_for_upkeep",
            "player": game.turn,
            "targets": list(range(len(p["field"])))
        }
        game.log.append(f"{game.turn.upper()}: 維持費不足！破棄するカードを選んでください")
        emit('update_ui', vars(game), broadcast=True)
        return
    
    # ドローフェーズ
    if p["deck"]: 
        p["hand"].append(p["deck"].pop(0))
    
    recalc_scores()
    emit('update_ui', vars(game), broadcast=True)

if __name__ == '__main__':
    socketio.run(app, debug=True, host='0.0.0.0', port=5000)
